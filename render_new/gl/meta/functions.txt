// VERSION_1_0
CullFace(GLenum mode)->void
FrontFace(GLenum mode)->void
Hint(GLenum target, GLenum mode)->void
LineWidth(GLfloat width)->void
PointSize(GLfloat size)->void
PolygonMode(GLenum face, GLenum mode)->void
Scissor(GLint x, GLint y, GLsizei width, GLsizei height)->void
TexParameterf(GLenum target, GLenum pname, GLfloat param)->void
TexParameterfv(GLenum target, GLenum pname, GLfloat *params)->void
TexParameteri(GLenum target, GLenum pname, GLint param)->void
TexParameteriv(GLenum target, GLenum pname, GLint *params)->void
TexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, void *pixels)->void
TexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, void *pixels)->void
DrawBuffer(GLenum mode)->void
Clear(GLbitfield mask)->void
ClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)->void
ClearStencil(GLint s)->void
ClearDepth(GLdouble depth)->void
StencilMask(GLuint mask)->void
ColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)->void
DepthMask(GLboolean flag)->void
Disable(GLenum cap)->void
Enable(GLenum cap)->void
Finish()->void
Flush()->void
BlendFunc(GLenum sfactor, GLenum dfactor)->void
LogicOp(GLenum opcode)->void
StencilFunc(GLenum func, GLint ref, GLuint mask)->void
StencilOp(GLenum fail, GLenum zfail, GLenum zpass)->void
DepthFunc(GLenum func)->void
PixelStoref(GLenum pname, GLfloat param)->void
PixelStorei(GLenum pname, GLint param)->void
ReadBuffer(GLenum src)->void
ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels)->void
GetBooleanv(GLenum pname, GLboolean *data)->void
GetDoublev(GLenum pname, GLdouble *data)->void
GetError()->GLenum
GetFloatv(GLenum pname, GLfloat *data)->void
GetIntegerv(GLenum pname, GLint *data)->void
GetString(GLenum name)->GLubyte*
GetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void *pixels)->void
GetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)->void
GetTexParameteriv(GLenum target, GLenum pname, GLint *params)->void
GetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)->void
GetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)->void
IsEnabled(GLenum cap)->GLboolean
DepthRange(GLdouble nearVal, GLdouble farVal)->void
Viewport(GLint x, GLint y, GLsizei width, GLsizei height)->void
// VERSION_1_1
DrawArrays(GLenum mode, GLint first, GLsizei count)->void
DrawElements(GLenum mode, GLsizei count, GLenum type, void *indices)->void
PolygonOffset(GLfloat factor, GLfloat units)->void
CopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)->void
CopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)->void
CopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)->void
CopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)->void
TexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, void *pixels)->void
TexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels)->void
BindTexture(GLenum target, GLuint texture)->void
DeleteTextures(GLsizei n, GLuint *textures)->void
GenTextures(GLsizei n, GLuint *textures)->void
IsTexture(GLuint texture)->GLboolean
// VERSION_1_2
DrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void *indices)->void
TexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, void *pixels)->void
TexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void *pixels)->void
CopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)->void
// VERSION_1_3
ActiveTexture(GLenum texture)->void
SampleCoverage(GLfloat value, GLboolean invert)->void
CompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, void *data)->void
CompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, void *data)->void
CompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, void *data)->void
CompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, void *data)->void
CompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, void *data)->void
CompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, void *data)->void
GetCompressedTexImage(GLenum target, GLint level, void *img)->void
// VERSION_1_4
BlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)->void
MultiDrawArrays(GLenum mode, GLint *first, GLsizei *count, GLsizei drawcount)->void
MultiDrawElements(GLenum mode, GLsizei *count, GLenum type, void **indices, GLsizei drawcount)->void
PointParameterf(GLenum pname, GLfloat param)->void
PointParameterfv(GLenum pname, GLfloat *params)->void
PointParameteri(GLenum pname, GLint param)->void
PointParameteriv(GLenum pname, GLint *params)->void
BlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)->void
BlendEquation(GLenum mode)->void
// VERSION_1_5
GenQueries(GLsizei n, GLuint *ids)->void
DeleteQueries(GLsizei n, GLuint *ids)->void
IsQuery(GLuint id)->GLboolean
BeginQuery(GLenum target, GLuint id)->void
EndQuery(GLenum target)->void
GetQueryiv(GLenum target, GLenum pname, GLint *params)->void
GetQueryObjectiv(GLuint id, GLenum pname, GLint *params)->void
GetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)->void
BindBuffer(GLenum target, GLuint buffer)->void
DeleteBuffers(GLsizei n, GLuint *buffers)->void
GenBuffers(GLsizei n, GLuint *buffers)->void
IsBuffer(GLuint buffer)->GLboolean
BufferData(GLenum target, GLsizeiptr size, void *data, GLenum usage)->void
BufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, void *data)->void
GetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, void *data)->void
MapBuffer(GLenum target, GLenum access)->void*
UnmapBuffer(GLenum target)->GLboolean
GetBufferParameteriv(GLenum target, GLenum pname, GLint *params)->void
GetBufferPointerv(GLenum target, GLenum pname, void **params)->void
// VERSION_2_0
BlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)->void
DrawBuffers(GLsizei n, GLenum *bufs)->void
StencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)->void
StencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)->void
StencilMaskSeparate(GLenum face, GLuint mask)->void
AttachShader(GLuint program, GLuint shader)->void
BindAttribLocation(GLuint program, GLuint index, GLstring name)->void
CompileShader(GLuint shader)->void
CreateProgram()->GLuint
CreateShader(GLenum type)->GLuint
DeleteProgram(GLuint program)->void
DeleteShader(GLuint shader)->void
DetachShader(GLuint program, GLuint shader)->void
DisableVertexAttribArray(GLuint index)->void
EnableVertexAttribArray(GLuint index)->void
GetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLstring name)->void
GetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLstring name)->void
GetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)->void
GetAttribLocation(GLuint program, GLstring name)->GLint
GetProgramiv(GLuint program, GLenum pname, GLint *params)->void
GetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLstring infoLog)->void
GetShaderiv(GLuint shader, GLenum pname, GLint *params)->void
GetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLstring infoLog)->void
GetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLstring source)->void
GetUniformLocation(GLuint program, GLstring name)->GLint
GetUniformfv(GLuint program, GLint location, GLfloat *params)->void
GetUniformiv(GLuint program, GLint location, GLint *params)->void
GetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)->void
GetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)->void
GetVertexAttribiv(GLuint index, GLenum pname, GLint *params)->void
GetVertexAttribPointerv(GLuint index, GLenum pname, void **pointer)->void
IsProgram(GLuint program)->GLboolean
IsShader(GLuint shader)->GLboolean
LinkProgram(GLuint program)->void
ShaderSource(GLuint shader, GLsizei count, GLstring *string, GLint *length)->void
UseProgram(GLuint program)->void
Uniform1f(GLint location, GLfloat v0)->void
Uniform2f(GLint location, GLfloat v0, GLfloat v1)->void
Uniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)->void
Uniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)->void
Uniform1i(GLint location, GLint v0)->void
Uniform2i(GLint location, GLint v0, GLint v1)->void
Uniform3i(GLint location, GLint v0, GLint v1, GLint v2)->void
Uniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)->void
Uniform1fv(GLint location, GLsizei count, GLfloat *value)->void
Uniform2fv(GLint location, GLsizei count, GLfloat *value)->void
Uniform3fv(GLint location, GLsizei count, GLfloat *value)->void
Uniform4fv(GLint location, GLsizei count, GLfloat *value)->void
Uniform1iv(GLint location, GLsizei count, GLint *value)->void
Uniform2iv(GLint location, GLsizei count, GLint *value)->void
Uniform3iv(GLint location, GLsizei count, GLint *value)->void
Uniform4iv(GLint location, GLsizei count, GLint *value)->void
UniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
UniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
UniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
ValidateProgram(GLuint program)->void
VertexAttrib1d(GLuint index, GLdouble x)->void
VertexAttrib1dv(GLuint index, GLdouble *v)->void
VertexAttrib1f(GLuint index, GLfloat x)->void
VertexAttrib1fv(GLuint index, GLfloat *v)->void
VertexAttrib1s(GLuint index, GLshort x)->void
VertexAttrib1sv(GLuint index, GLshort *v)->void
VertexAttrib2d(GLuint index, GLdouble x, GLdouble y)->void
VertexAttrib2dv(GLuint index, GLdouble *v)->void
VertexAttrib2f(GLuint index, GLfloat x, GLfloat y)->void
VertexAttrib2fv(GLuint index, GLfloat *v)->void
VertexAttrib2s(GLuint index, GLshort x, GLshort y)->void
VertexAttrib2sv(GLuint index, GLshort *v)->void
VertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)->void
VertexAttrib3dv(GLuint index, GLdouble *v)->void
VertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)->void
VertexAttrib3fv(GLuint index, GLfloat *v)->void
VertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)->void
VertexAttrib3sv(GLuint index, GLshort *v)->void
VertexAttrib4Nbv(GLuint index, GLbyte *v)->void
VertexAttrib4Niv(GLuint index, GLint *v)->void
VertexAttrib4Nsv(GLuint index, GLshort *v)->void
VertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)->void
VertexAttrib4Nubv(GLuint index, GLubyte *v)->void
VertexAttrib4Nuiv(GLuint index, GLuint *v)->void
VertexAttrib4Nusv(GLuint index, GLushort *v)->void
VertexAttrib4bv(GLuint index, GLbyte *v)->void
VertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)->void
VertexAttrib4dv(GLuint index, GLdouble *v)->void
VertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)->void
VertexAttrib4fv(GLuint index, GLfloat *v)->void
VertexAttrib4iv(GLuint index, GLint *v)->void
VertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)->void
VertexAttrib4sv(GLuint index, GLshort *v)->void
VertexAttrib4ubv(GLuint index, GLubyte *v)->void
VertexAttrib4uiv(GLuint index, GLuint *v)->void
VertexAttrib4usv(GLuint index, GLushort *v)->void
VertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, void *pointer)->void
// VERSION_2_1
UniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
UniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
UniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
UniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
UniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
UniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
//VERSION_3_0
ColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)->void
GetBooleani_v(GLenum target, GLuint index, GLboolean *data)->void
GetIntegeri_v(GLenum target, GLuint index, GLint *data)->void
Enablei(GLenum target, GLuint index)->void
Disablei(GLenum target, GLuint index)->void
IsEnabledi(GLenum target, GLuint index)->GLboolean
BeginTransformFeedback(GLenum primitiveMode)->void
EndTransformFeedback()->void
BindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)->void
BindBufferBase(GLenum target, GLuint index, GLuint buffer)->void
TransformFeedbackVaryings(GLuint program, GLsizei count, GLstring *varyings, GLenum bufferMode)->void
GetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLstring name)->void
ClampColor(GLenum target, GLenum clamp)->void
BeginConditionalRender(GLuint id, GLenum mode)->void
EndConditionalRender()->void
VertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, void *pointer)->void
GetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)->void
GetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)->void
VertexAttribI1i(GLuint index, GLint x)->void
VertexAttribI2i(GLuint index, GLint x, GLint y)->void
VertexAttribI3i(GLuint index, GLint x, GLint y, GLint z)->void
VertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w)->void
VertexAttribI1ui(GLuint index, GLuint x)->void
VertexAttribI2ui(GLuint index, GLuint x, GLuint y)->void
VertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z)->void
VertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)->void
VertexAttribI1iv(GLuint index, GLint *v)->void
VertexAttribI2iv(GLuint index, GLint *v)->void
VertexAttribI3iv(GLuint index, GLint *v)->void
VertexAttribI4iv(GLuint index, GLint *v)->void
VertexAttribI1uiv(GLuint index, GLuint *v)->void
VertexAttribI2uiv(GLuint index, GLuint *v)->void
VertexAttribI3uiv(GLuint index, GLuint *v)->void
VertexAttribI4uiv(GLuint index, GLuint *v)->void
VertexAttribI4bv(GLuint index, GLbyte *v)->void
VertexAttribI4sv(GLuint index, GLshort *v)->void
VertexAttribI4ubv(GLuint index, GLubyte *v)->void
VertexAttribI4usv(GLuint index, GLushort *v)->void
GetUniformuiv(GLuint program, GLint location, GLuint *params)->void
BindFragDataLocation(GLuint program, GLuint color, GLstring name)->void
GetFragDataLocation(GLuint program, GLstring name)->GLint
Uniform1ui(GLint location, GLuint v0)->void
Uniform2ui(GLint location, GLuint v0, GLuint v1)->void
Uniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)->void
Uniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)->void
Uniform1uiv(GLint location, GLsizei count, GLuint *value)->void
Uniform2uiv(GLint location, GLsizei count, GLuint *value)->void
Uniform3uiv(GLint location, GLsizei count, GLuint *value)->void
Uniform4uiv(GLint location, GLsizei count, GLuint *value)->void
TexParameterIiv(GLenum target, GLenum pname, GLint *params)->void
TexParameterIuiv(GLenum target, GLenum pname, GLuint *params)->void
GetTexParameterIiv(GLenum target, GLenum pname, GLint *params)->void
GetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)->void
ClearBufferiv(GLenum buffer, GLint drawbuffer, GLint *value)->void
ClearBufferuiv(GLenum buffer, GLint drawbuffer, GLuint *value)->void
ClearBufferfv(GLenum buffer, GLint drawbuffer, GLfloat *value)->void
ClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)->void
GetStringi(GLenum name, GLuint index)->GLubyte*
IsRenderbuffer(GLuint renderbuffer)->GLboolean
BindRenderbuffer(GLenum target, GLuint renderbuffer)->void
DeleteRenderbuffers(GLsizei n, GLuint *renderbuffers)->void
GenRenderbuffers(GLsizei n, GLuint *renderbuffers)->void
RenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)->void
GetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)->void
IsFramebuffer(GLuint framebuffer)->GLboolean
BindFramebuffer(GLenum target, GLuint framebuffer)->void
DeleteFramebuffers(GLsizei n, GLuint *framebuffers)->void
GenFramebuffers(GLsizei n, GLuint *framebuffers)->void
CheckFramebufferStatus(GLenum target)->GLenum
FramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)->void
FramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)->void
FramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)->void
FramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)->void
GetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)->void
GenerateMipmap(GLenum target)->void
BlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)->void
RenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)->void
FramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)->void
MapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)->void*
FlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)->void
BindVertexArray(GLuint array)->void
DeleteVertexArrays(GLsizei n, GLuint *arrays)->void
GenVertexArrays(GLsizei n, GLuint *arrays)->void
IsVertexArray(GLuint array)->GLboolean
// VERSION_3_1
DrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount)->void
DrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, void *indices, GLsizei instancecount)->void
TexBuffer(GLenum target, GLenum internalformat, GLuint buffer)->void
PrimitiveRestartIndex(GLuint index)->void
CopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)->void
GetUniformIndices(GLuint program, GLsizei uniformCount, GLstring *uniformNames, GLuint *uniformIndices)->void
GetActiveUniformsiv(GLuint program, GLsizei uniformCount, GLuint *uniformIndices, GLenum pname, GLint *params)->void
GetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName)->void
GetUniformBlockIndex(GLuint program, GLstring uniformBlockName)->GLuint
GetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)->void
GetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)->void
UniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)->void
// VERSION_3_2
DrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, void *indices, GLint basevertex)->void
DrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void *indices, GLint basevertex)->void
DrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, void *indices, GLsizei instancecount, GLint basevertex)->void
MultiDrawElementsBaseVertex(GLenum mode, GLsizei *count, GLenum type, void **indices, GLsizei drawcount, GLint *basevertex)->void
ProvokingVertex(GLenum mode)->void
FenceSync(GLenum condition, GLbitfield flags)->GLsync
IsSync(GLsync sync)->GLboolean
DeleteSync(GLsync sync)->void
ClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)->GLenum
WaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)->void
GetInteger64v(GLenum pname, GLint64 *data)->void
GetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)->void
GetInteger64i_v(GLenum target, GLuint index, GLint64 *data)->void
GetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params)->void
FramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level)->void
TexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)->void
TexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)->void
GetMultisamplefv(GLenum pname, GLuint index, GLfloat *val)->void
SampleMaski(GLuint maskNumber, GLbitfield mask)->void
// VERSION_3_3
BindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, GLstring name)->void
GetFragDataIndex(GLuint program, GLstring name)->GLint
GenSamplers(GLsizei count, GLuint *samplers)->void
DeleteSamplers(GLsizei count, GLuint *samplers)->void
IsSampler(GLuint sampler)->GLboolean
BindSampler(GLuint unit, GLuint sampler)->void
SamplerParameteri(GLuint sampler, GLenum pname, GLint param)->void
SamplerParameteriv(GLuint sampler, GLenum pname, GLint *param)->void
SamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)->void
SamplerParameterfv(GLuint sampler, GLenum pname, GLfloat *param)->void
SamplerParameterIiv(GLuint sampler, GLenum pname, GLint *param)->void
SamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint *param)->void
GetSamplerParameteriv(GLuint sampler, GLenum pname, GLint *params)->void
GetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint *params)->void
GetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat *params)->void
GetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint *params)->void
QueryCounter(GLuint id, GLenum target)->void
GetQueryObjecti64v(GLuint id, GLenum pname, GLint64 *params)->void
GetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 *params)->void
VertexAttribDivisor(GLuint index, GLuint divisor)->void
VertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)->void
VertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, GLuint *value)->void
VertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)->void
VertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, GLuint *value)->void
VertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)->void
VertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, GLuint *value)->void
VertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)->void
VertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, GLuint *value)->void
VertexP2ui(GLenum type, GLuint value)->void
VertexP2uiv(GLenum type, GLuint *value)->void
VertexP3ui(GLenum type, GLuint value)->void
VertexP3uiv(GLenum type, GLuint *value)->void
VertexP4ui(GLenum type, GLuint value)->void
VertexP4uiv(GLenum type, GLuint *value)->void
TexCoordP1ui(GLenum type, GLuint coords)->void
TexCoordP1uiv(GLenum type, GLuint *coords)->void
TexCoordP2ui(GLenum type, GLuint coords)->void
TexCoordP2uiv(GLenum type, GLuint *coords)->void
TexCoordP3ui(GLenum type, GLuint coords)->void
TexCoordP3uiv(GLenum type, GLuint *coords)->void
TexCoordP4ui(GLenum type, GLuint coords)->void
TexCoordP4uiv(GLenum type, GLuint *coords)->void
MultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords)->void
MultiTexCoordP1uiv(GLenum texture, GLenum type, GLuint *coords)->void
MultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords)->void
MultiTexCoordP2uiv(GLenum texture, GLenum type, GLuint *coords)->void
MultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords)->void
MultiTexCoordP3uiv(GLenum texture, GLenum type, GLuint *coords)->void
MultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords)->void
MultiTexCoordP4uiv(GLenum texture, GLenum type, GLuint *coords)->void
NormalP3ui(GLenum type, GLuint coords)->void
NormalP3uiv(GLenum type, GLuint *coords)->void
ColorP3ui(GLenum type, GLuint color)->void
ColorP3uiv(GLenum type, GLuint *color)->void
ColorP4ui(GLenum type, GLuint color)->void
ColorP4uiv(GLenum type, GLuint *color)->void
SecondaryColorP3ui(GLenum type, GLuint color)->void
SecondaryColorP3uiv(GLenum type, GLuint *color)->void
// VERSION_4_0
MinSampleShading(GLfloat value)->void
BlendEquationi(GLuint buf, GLenum mode)->void
BlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha)->void
BlendFunci(GLuint buf, GLenum src, GLenum dst)->void
BlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)->void
DrawArraysIndirect(GLenum mode, void *indirect)->void
DrawElementsIndirect(GLenum mode, GLenum type, void *indirect)->void
Uniform1d(GLint location, GLdouble x)->void
Uniform2d(GLint location, GLdouble x, GLdouble y)->void
Uniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z)->void
Uniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)->void
Uniform1dv(GLint location, GLsizei count, GLdouble *value)->void
Uniform2dv(GLint location, GLsizei count, GLdouble *value)->void
Uniform3dv(GLint location, GLsizei count, GLdouble *value)->void
Uniform4dv(GLint location, GLsizei count, GLdouble *value)->void
UniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
UniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
UniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
UniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
UniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
UniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
UniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
UniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
UniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
GetUniformdv(GLuint program, GLint location, GLdouble *params)->void
GetSubroutineUniformLocation(GLuint program, GLenum shadertype, GLstring name)->GLint
GetSubroutineIndex(GLuint program, GLenum shadertype, GLstring name)->GLuint
GetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values)->void
GetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLstring name)->void
GetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLstring name)->void
UniformSubroutinesuiv(GLenum shadertype, GLsizei count, GLuint *indices)->void
GetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint *params)->void
GetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint *values)->void
PatchParameteri(GLenum pname, GLint value)->void
PatchParameterfv(GLenum pname, GLfloat *values)->void
BindTransformFeedback(GLenum target, GLuint id)->void
DeleteTransformFeedbacks(GLsizei n, GLuint *ids)->void
GenTransformFeedbacks(GLsizei n, GLuint *ids)->void
IsTransformFeedback(GLuint id)->GLboolean
PauseTransformFeedback()->void
ResumeTransformFeedback()->void
DrawTransformFeedback(GLenum mode, GLuint id)->void
DrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream)->void
BeginQueryIndexed(GLenum target, GLuint index, GLuint id)->void
EndQueryIndexed(GLenum target, GLuint index)->void
GetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint *params)->void
GetTextureHandleARB(GLenum target)->GLuint64
GetTextureSamplerHandleARB(GLenum target, GLuint sampler)->GLuint64
GetImageHandleARB(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format)->GLuint64
MakeTextureHandleResidentARB(GLuint64 handle)->void
MakeImageHandleResidentARB(GLuint64 handle, GLenum access)->void
MakeTextureHandleNonResidentARB(GLuint64 handle)->void
MakeImageHandleNonResidentARB(GLuint64 handle)->void
// VERSION_4_1
ReleaseShaderCompiler()->void
ShaderBinary(GLsizei count, GLuint *shaders, GLenum binaryFormat, void *binary, GLsizei length)->void
GetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision)->void
DepthRangef(GLfloat n, GLfloat f)->void
ClearDepthf(GLfloat d)->void
GetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary)->void
ProgramBinary(GLuint program, GLenum binaryFormat, void *binary, GLsizei length)->void
ProgramParameteri(GLuint program, GLenum pname, GLint value)->void
UseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)->void
ActiveShaderProgram(GLuint pipeline, GLuint program)->void
CreateShaderProgramv(GLenum type, GLsizei count, GLstring const*strings)->GLuint
BindProgramPipeline(GLuint pipeline)->void
DeleteProgramPipelines(GLsizei n, GLuint *pipelines)->void
GenProgramPipelines(GLsizei n, GLuint *pipelines)->void
IsProgramPipeline(GLuint pipeline)->GLboolean
GetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params)->void
ProgramUniform1i(GLuint program, GLint location, GLint v0)->void
ProgramUniform1iv(GLuint program, GLint location, GLsizei count, GLint *value)->void
ProgramUniform1f(GLuint program, GLint location, GLfloat v0)->void
ProgramUniform1fv(GLuint program, GLint location, GLsizei count, GLfloat *value)->void
ProgramUniform1d(GLuint program, GLint location, GLdouble v0)->void
ProgramUniform1dv(GLuint program, GLint location, GLsizei count, GLdouble *value)->void
ProgramUniform1ui(GLuint program, GLint location, GLuint v0)->void
ProgramUniform1uiv(GLuint program, GLint location, GLsizei count, GLuint *value)->void
ProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1)->void
ProgramUniform2iv(GLuint program, GLint location, GLsizei count, GLint *value)->void
ProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1)->void
ProgramUniform2fv(GLuint program, GLint location, GLsizei count, GLfloat *value)->void
ProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1)->void
ProgramUniform2dv(GLuint program, GLint location, GLsizei count, GLdouble *value)->void
ProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1)->void
ProgramUniform2uiv(GLuint program, GLint location, GLsizei count, GLuint *value)->void
ProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)->void
ProgramUniform3iv(GLuint program, GLint location, GLsizei count, GLint *value)->void
ProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)->void
ProgramUniform3fv(GLuint program, GLint location, GLsizei count, GLfloat *value)->void
ProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2)->void
ProgramUniform3dv(GLuint program, GLint location, GLsizei count, GLdouble *value)->void
ProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)->void
ProgramUniform3uiv(GLuint program, GLint location, GLsizei count, GLuint *value)->void
ProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)->void
ProgramUniform4iv(GLuint program, GLint location, GLsizei count, GLint *value)->void
ProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)->void
ProgramUniform4fv(GLuint program, GLint location, GLsizei count, GLfloat *value)->void
ProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3)->void
ProgramUniform4dv(GLuint program, GLint location, GLsizei count, GLdouble *value)->void
ProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)->void
ProgramUniform4uiv(GLuint program, GLint location, GLsizei count, GLuint *value)->void
ProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
ProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
ProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
ProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
ProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
ProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
ProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
ProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
ProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
ProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
ProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
ProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat *value)->void
ProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
ProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
ProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
ProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
ProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
ProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble *value)->void
ValidateProgramPipeline(GLuint pipeline)->void
GetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLstring infoLog)->void
VertexAttribL1d(GLuint index, GLdouble x)->void
VertexAttribL2d(GLuint index, GLdouble x, GLdouble y)->void
VertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)->void
VertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)->void
VertexAttribL1dv(GLuint index, GLdouble *v)->void
VertexAttribL2dv(GLuint index, GLdouble *v)->void
VertexAttribL3dv(GLuint index, GLdouble *v)->void
VertexAttribL4dv(GLuint index, GLdouble *v)->void
VertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, void *pointer)->void
GetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params)->void
ViewportArrayv(GLuint first, GLsizei count, GLfloat *v)->void
ViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)->void
ViewportIndexedfv(GLuint index, GLfloat *v)->void
ScissorArrayv(GLuint first, GLsizei count, GLint *v)->void
ScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height)->void
ScissorIndexedv(GLuint index, GLint *v)->void
DepthRangeArrayv(GLuint first, GLsizei count, GLdouble *v)->void
DepthRangeIndexed(GLuint index, GLdouble n, GLdouble f)->void
GetFloati_v(GLenum target, GLuint index, GLfloat *data)->void
GetDoublei_v(GLenum target, GLuint index, GLdouble *data)->void
// VERSION_4_2
DrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance)->void
DrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, void *indices, GLsizei instancecount, GLuint baseinstance)->void
DrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance)->void
GetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)->void
GetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params)->void
BindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)->void
MemoryBarrier(GLbitfield barriers)->void
TexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)->void
TexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)->void
TexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)->void
DrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei instancecount)->void
DrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount)->void
// VERSION_4_3
ClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, void *data)->void
ClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, void *data)->void
DispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)->void
DispatchComputeIndirect(GLintptr indirect)->void
CopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)->void
FramebufferParameteri(GLenum target, GLenum pname, GLint param)->void
GetFramebufferParameteriv(GLenum target, GLenum pname, GLint *params)->void
GetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params)->void
InvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth)->void
InvalidateTexImage(GLuint texture, GLint level)->void
InvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length)->void
InvalidateBufferData(GLuint buffer)->void
InvalidateFramebuffer(GLenum target, GLsizei numAttachments, GLenum *attachments)->void
InvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height)->void
MultiDrawArraysIndirect(GLenum mode, void *indirect, GLsizei drawcount, GLsizei stride)->void
MultiDrawElementsIndirect(GLenum mode, GLenum type, void *indirect, GLsizei drawcount, GLsizei stride)->void
GetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint *params)->void
GetProgramResourceIndex(GLuint program, GLenum programInterface, GLstring name)->GLuint
GetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLstring name)->void
GetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params)->void
GetProgramResourceLocation(GLuint program, GLenum programInterface, GLstring name)->GLint
GetProgramResourceLocationIndex(GLuint program, GLenum programInterface, GLstring name)->GLint
ShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding)->void
TexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)->void
TexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)->void
TexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)->void
TextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers)->void
BindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)->void
VertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)->void
VertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)->void
VertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)->void
VertexAttribBinding(GLuint attribindex, GLuint bindingindex)->void
VertexBindingDivisor(GLuint bindingindex, GLuint divisor)->void
DebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, GLuint *ids, GLboolean enabled)->void
DebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, GLstring buf)->void
DebugMessageCallback(GLdebugproc callback, void *userParam)->void
GetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLstring messageLog)->GLuint
PushDebugGroup(GLenum source, GLuint id, GLsizei length, GLstring message)->void
PopDebugGroup()->void
ObjectLabel(GLenum identifier, GLuint name, GLsizei length, GLstring label)->void
GetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLstring label)->void
ObjectPtrLabel(void *ptr, GLsizei length, GLstring label)->void
GetObjectPtrLabel(void *ptr, GLsizei bufSize, GLsizei *length, GLstring label)->void
// VERSION_4_4
BufferStorage(GLenum target, GLsizeiptr size, void *data, GLbitfield flags)->void
ClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, void *data)->void
ClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void *data)->void
BindBuffersBase(GLenum target, GLuint first, GLsizei count, GLuint *buffers)->void
BindBuffersRange(GLenum target, GLuint first, GLsizei count, GLuint *buffers, GLintptr *offsets, GLsizeiptr *sizes)->void
BindTextures(GLuint first, GLsizei count, GLuint *textures)->void
BindSamplers(GLuint first, GLsizei count, GLuint *samplers)->void
BindImageTextures(GLuint first, GLsizei count, GLuint *textures)->void
BindVertexBuffers(GLuint first, GLsizei count, GLuint *buffers, GLintptr *offsets, GLsizei *strides)->void
// VERSION_4_5
ClipControl(GLenum origin, GLenum depth)->void
CreateTransformFeedbacks(GLsizei n, GLuint *ids)->void
TransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer)->void
TransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)->void
GetTransformFeedbackiv(GLuint xfb, GLenum pname, GLint *param)->void
GetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, GLint *param)->void
GetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, GLint64 *param)->void
CreateBuffers(GLsizei n, GLuint *buffers)->void
NamedBufferStorage(GLuint buffer, GLsizeiptr size, void *data, GLbitfield flags)->void
NamedBufferData(GLuint buffer, GLsizeiptr size, void *data, GLenum usage)->void
NamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data)->void
CopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)->void
ClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, void *data)->void
ClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, void *data)->void
MapNamedBuffer(GLuint buffer, GLenum access)->void*
MapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)->void*
UnmapNamedBuffer(GLuint buffer)->GLboolean
FlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length)->void
GetNamedBufferParameteriv(GLuint buffer, GLenum pname, GLint *params)->void
GetNamedBufferParameteri64v(GLuint buffer, GLenum pname, GLint64 *params)->void
GetNamedBufferPointerv(GLuint buffer, GLenum pname, void **params)->void
GetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data)->void
CreateFramebuffers(GLsizei n, GLuint* framebuffers)->void
NamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)->void
NamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param)->void
NamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)->void
NamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)->void
NamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf)->void
NamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, GLenum *bufs)->void
NamedFramebufferReadBuffer(GLuint framebuffer, GLenum src)->void
InvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, GLenum *attachments)->void
InvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height)->void
ClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLint *value)->void
ClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLuint *value)->void
ClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat *value)->void
ClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)->void
BlitNamedFramebuffer(GLuint srcFramebuffer, GLuint dstFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)->void
CheckNamedFramebufferStatus(GLuint framebuffer, GLenum target)->GLenum
GetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, GLint *param)->void
GetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params)->void
CreateRenderbuffers(GLsizei n, GLuint *renderbuffers)->void
NamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)->void
NamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)->void
GetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, GLint *params)->void
CreateTextures(GLenum target, GLsizei n, GLuint *textures)->void
TextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer)->void
TextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)->void
TextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width)->void
TextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)->void
TextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)->void
TextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)->void
TextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)->void
TextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, void *pixels)->void
TextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels)->void
TextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void *pixels)->void
CompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, void *data)->void
CompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, void *data)->void
CompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, void *data)->void
CopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)->void
CopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)->void
CopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)->void
TextureParameterf(GLuint texture, GLenum pname, GLfloat param)->void
TextureParameterfv(GLuint texture, GLenum pname, GLfloat *param)->void
TextureParameteri(GLuint texture, GLenum pname, GLint param)->void
TextureParameterIiv(GLuint texture, GLenum pname, GLint *params)->void
TextureParameterIuiv(GLuint texture, GLenum pname, GLuint *params)->void
TextureParameteriv(GLuint texture, GLenum pname, GLint *param)->void
GenerateTextureMipmap(GLuint texture)->void
BindTextureUnit(GLuint unit, GLuint texture)->void
GetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels)->void
GetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void *pixels)->void
GetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, GLfloat *params)->void
GetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, GLint *params)->void
GetTextureParameterfv(GLuint texture, GLenum pname, GLfloat *params)->void
GetTextureParameterIiv(GLuint texture, GLenum pname, GLint *params)->void
GetTextureParameterIuiv(GLuint texture, GLenum pname, GLuint *params)->void
GetTextureParameteriv(GLuint texture, GLenum pname, GLint *params)->void
CreateVertexArrays(GLsizei n, GLuint *arrays)->void
DisableVertexArrayAttrib(GLuint vaobj, GLuint index)->void
EnableVertexArrayAttrib(GLuint vaobj, GLuint index)->void
VertexArrayElementBuffer(GLuint vaobj, GLuint buffer)->void
VertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)->void
VertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, GLuint *buffers, GLintptr *offsets, GLsizei *strides)->void
VertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex)->void
VertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)->void
VertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)->void
VertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)->void
VertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor)->void
GetVertexArrayiv(GLuint vaobj, GLenum pname, GLint *param)->void
GetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, GLint *param)->void
GetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64 *param)->void
CreateSamplers(GLsizei n, GLuint *samplers)->void
CreateProgramPipelines(GLsizei n, GLuint *pipelines)->void
CreateQueries(GLenum target, GLsizei n, GLuint *ids)->void
GetQueryBufferObjecti64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset)->void
GetQueryBufferObjectiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset)->void
GetQueryBufferObjectui64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset)->void
GetQueryBufferObjectuiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset)->void
MemoryBarrierByRegion(GLbitfield barriers)->void
GetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels)->void
GetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels)->void
GetGraphicsResetStatus()->GLenum
GetnCompressedTexImage(GLenum target, GLint lod, GLsizei bufSize, void *pixels)->void
GetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels)->void
GetnUniformdv(GLuint program, GLint location, GLsizei bufSize, GLdouble *params)->void
GetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)->void
GetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint *params)->void
GetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint *params)->void
ReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data)->void
GetnMapdv(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v)->void
GetnMapfv(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v)->void
GetnMapiv(GLenum target, GLenum query, GLsizei bufSize, GLint *v)->void
GetnPixelMapusv(GLenum map, GLsizei bufSize, GLushort *values)->void
GetnPixelMapfv(GLenum map, GLsizei bufSize, GLfloat *values)->void
GetnPixelMapuiv(GLenum map, GLsizei bufSize, GLuint *values)->void
GetnPolygonStipple(GLsizei bufSize, GLubyte *pattern)->void
GetnColorTable(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table)->void
GetnConvolutionFilter(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image)->void
GetnSeparableFilter(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span)->void
GetnHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values)->void
GetnMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values)->void
TextureBarrier()->void
GetUnsignedBytevEXT(GLenum pname, GLubyte *data)->void
// VERSION_4_6
TexPageCommitmentARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit)->void
SpecializeShader(GLuint shader, GLstring pEntryPoint, GLuint numSpecializationConstants, GLuint *pConstantIndex, GLuint *pConstantValue)->void
MultiDrawArraysIndirectCount(GLenum mode, void *indirect, GLsizei drawcount, GLsizei maxdrawcount, GLsizei stride)->void
MultiDrawElementsIndirectCount(GLenum mode, GLenum type, void *indirect, GLsizei drawcount, GLsizei maxdrawcount, GLsizei stride)->void
PolygonOffsetClamp(GLfloat factor, GLfloat units, GLfloat clamp)->void